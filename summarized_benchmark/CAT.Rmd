---
title: "Concordance at the top"
author: "Enrico Gaffo"
date: 'Compiled: `r format(Sys.Date(), "%d %B, %Y")`'
output:
  html_document:
    code_folding: hide
    df_print: kable
    number_sections: no
    theme: united
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
editor_options: 
  chunk_output_type: console
---

<style>
#TOC {
  top: 1%;
  opacity: 0.5;
}
#TOC:hover {
  opacity: 1;
}
</style>

```{r setup, include=FALSE}
current.dir = "."

# knitr::opts_chunk$set(echo = TRUE, fig.path = file.path(current.dir, "consinstency/"))
```

```{r message=FALSE, warning=FALSE}
library(data.table)
# library(qs) ## to fast saving the results

library(ggplot2)
library(viridis)
library(ggdendro)
library(dendsort)
library(scales)

library(ffpe) ## for the CATplot
library(pracma) ## for the trapezoidal function used to compute AUC

library(BiocParallel)
```

```{r}
#' m1, m2 are character strings with the name of the methods to intersect
#' dt is a sorted data.table of method scores, with 'Method' and 'Cid' columns, 
#' which are the name of the method's score and the circRNA identifier, respectively.
getCAT_dt <- function(m1, m2, dt, maxrank = 100) {
    
    data.table::data.table(method1 = m1, 
                           method2 = m2, 
                           ffpe::CATplot(vec1 = dt[Method == m1, Cid],
                                         vec2 = dt[Method == m2, Cid], 
                                         maxrank = maxrank, 
                                         make.plot = F))
}
```

# Between method concordance at the top

```{r}
## data set names prefix
Datasets <- c("DM1", "IDC", "IPF","MS")

resDE_datasets <- sapply(Datasets,
                         function(d) fread(file = file.path(".", 
                                                            paste0(d, "_evaluations/pval_deind.csv.gz")), 
                                           showProgress = F),
                         simplify = F, USE.NAMES = T)

preds_dt <- 
  rbindlist(resDE_datasets, 
            use.names = T, 
            idcol = "DS")[, Cid := seq_along(preds), 
                          by = .(DS, Dataset,  
                                 Method)][order(preds, na.last = T), 
                                          .(DS = paste(DS, Dataset, sep = "_"),
                                            Cid, Method, preds)]

method_names <- sort(unique(preds_dt$Method))

preds_dt$Method <- factor(preds_dt$Method, 
                          levels = method_names, 
                          ordered = T)

method_colors <- setNames(hue_pal()(length(method_names)), method_names)
```


```{r}
cats <- 
  rbindlist(bplapply(X = split(x = preds_dt, f = preds_dt$DS), 
                     FUN = function(dt){
                       
                       # m12 <- expand.grid(m1 = unique(dt$Method), 
                       #                    m2 = unique(dt$Method))
                       # ## remove method match with itself
                       # m12 <- m12[!m12$m1 == m12$m2,]
                       
                       ## CAT is symmetric, therefore we can exclude half the pairs
                       m12 <- data.table(t(combn(levels(dt$Method), m = 2)))
                       
                       rbindlist(mapply(getCAT_dt, 
                                        m1 = m12$V1, m2 = m12$V2, 
                                        MoreArgs = list(dt = dt, maxrank = 100), 
                                        SIMPLIFY = F))}, 
                     BPPARAM = MulticoreParam(workers = multicoreWorkers())), 
            use.names = T, idcol = "Dataset")

cats[, featFrac := rank / max(rank), by = .(Dataset, method1, method2)]
```


```{r}
## get the area under the CAT curve
aucats <- cats[, .(AUCAT = pracma::trapz(featFrac, concordance)), 
               by = .(Dataset, method1, method2)]

## mean AUCAT across all simulated data sets
maucats <- aucats[, .(MeanAUCAT = mean(AUCAT)), 
                  by = .(method1, method2)]
```


```{r} 
## mean concordance score at each rank across all simulated data sets
mconc <- cats[, .(concordance = mean(concordance)), 
              by = .(method1, method2, featFrac)]

## AUCAT according to the rank mean concordance
## NB: attach a new column (with redundant values) to ease later plotting
mconc[, AUCAT := trapz(featFrac, concordance), 
      by = .(method1, method2)]
```


```{r} 
## compose a matrix for clustering and heatmap plotting
maucats_mat <- as.matrix(data.frame(dcast(maucats,
                                          method1 ~ method2, 
                                          value.var = "MeanAUCAT", 
                                          drop = F,
                                          fill = NA), 
                                    row.names = "method1"))

## N.B. only the upper/lower tringular of the matrix is
maucats_mat <- maucats_mat[sort(rownames(maucats_mat)),
                           sort(colnames(maucats_mat))]

## add NA diagonal
cnames <- c(setdiff(rownames(maucats_mat), colnames(maucats_mat)), colnames(maucats_mat))
rnames <- c(rownames(maucats_mat), setdiff(colnames(maucats_mat), rownames(maucats_mat)))

maucats_mat <- cbind(rep(NA, nrow(maucats_mat)),
                     maucats_mat)
maucats_mat <- rbind(maucats_mat,
                     rep(NA, ncol(maucats_mat)))

colnames(maucats_mat) <- cnames
rownames(maucats_mat) <- rnames
# dim(maucats_mat)

maucats_mat[lower.tri(maucats_mat, diag = F)] <- t(maucats_mat)[lower.tri(maucats_mat, diag = F)]

## just check everything is ok
# isSymmetric(maucats_mat)
```

## Heatmaps {.tabset}

### Not clustered

```{r, fig.width=8, fig.height=8} 
## check visually with a heatmap, without any method rearrangement
pheatmap::pheatmap(maucats_mat, 
                   main = "Area under concordance at the 100 top ranked DECs",
                   scale = "none",
                   color = viridis(255, option = "B"),
                   cluster_cols = F, 
                   cellwidth = 10, cellheight = 10,
                   cluster_rows = F)
```

### Clustered

```{r} 
## compute clustering of the methods according to AUCAT: the larger the AUCAT 
## between methods, the more similar the methods.
## Use dendsort to improve visualization

# maucats_clust <- hclust(as.dist(1 - maucats_mat))
maucats_clust <- dendsort(hclust(as.dist(1 - maucats_mat)))
# plot(maucats_clust)

# maucats_clust
labels_clust_order <- maucats_clust$labels[maucats_clust$order]
```

```{r, fig.width=8.5, fig.height=8.5} 
pheatmap::pheatmap(maucats_mat, 
                   main = "Area under concordance at the 100 top ranked DECs",
                   color = viridis(255, option = "B"), 
                   # cutree_rows = 6, cutree_cols = 6,
                   cellwidth = 10, cellheight = 10,
                   cluster_cols = maucats_clust,
                   cluster_rows = maucats_clust)
```


```{r, fig.width=8.5, fig.height=8.5} 
# pheatmap::pheatmap(maucats_mat, 
#                    scale = "none",
#                    color = viridis(255, option = "B"),
#                    cellwidth = 10, cellheight = 10,
#                    cluster_cols = T,
#                    cluster_rows = T)
```

### Corrplot unclustered

```{r, fig.width=8.5, fig.height=8.5} 
corrplot::corrplot(maucats_mat, 
                   col = viridis(255, option = "B"),
                   type = "upper", 
                   is.corr = F, 
                   diag = F)
```

### Corrplot clustered

```{r, fig.width=8.5, fig.height=8.5} 
corrplot::corrplot(corr = maucats_mat[labels_clust_order, labels_clust_order], 
                   col = viridis(255, option = "B"),
                   type = "upper", 
                   is.corr = F, 
                   diag = F)
```

## AUCAT heat plot

```{r, fig.width=9, fig.height=8.5} 
plot_dt <- copy(mconc)

plot_dt <- 
    rbindlist(list(plot_dt, 
                   copy(plot_dt)[, tmp := method1][, .(method1 = method2, 
                                                       method2 = tmp, 
                                                       featFrac, 
                                                       concordance, 
                                                       AUCAT)]))

plot_dt$method1 <- factor(plot_dt$method1, 
                          levels = labels_clust_order,
                          ordered = T)

plot_dt$method2 <- factor(plot_dt$method2, 
                          levels = rev(labels_clust_order),
                          ordered = T)

aucat_heatplot <- 
  ggplot(plot_dt, aes(x = featFrac, y = concordance, fill = AUCAT)) +
  geom_area() +
  facet_grid(rows = vars(method1), cols = vars(method2), drop = F) +
  scale_fill_viridis() +
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
  theme_dendro() ## theme dendro removes almost everything

aucat_heatplot + 
  theme(legend.position = "left",
        strip.text.y = element_text(angle =  0, hjust = 0), #, colour = method_colors[rev(labels_clust_order)]
        strip.text.x = element_text(angle = 90, hjust = 0), #, colour = method_colors[labels_clust_order]
        strip.background = element_blank(),
        panel.spacing = unit(0, "cm"))
```

## AUCAT dendrogram

```{r, warning=FALSE, fig.width=9, fig.height=3}
ddata <- 
  dendro_data(as.dendrogram(maucats_clust, isReverse = T),
              type = "rectangle")

top_dendro <- 
  ggplot(segment(ddata), aes(x = x, y = y)) +
  geom_segment(aes(xend = xend, yend = yend)) +
  scale_x_continuous(name = NULL, 
                     trans = "reverse",
                     breaks = label(ddata)$x, 
                     labels = label(ddata)$label, 
                     expand = c(0, 0),
                     position = "bottom") +
  # scale_y_reverse(name = NULL, expand = c(0, 0.01)) +
  scale_y_continuous(name = NULL, expand = c(0, 0)) +
  # coord_flip() +
  # theme_minimal() +
  theme_dendro() +
  theme(axis.text.x = element_text(color = method_colors[label(ddata)$label], 
                                   angle = 90, hjust = 1, vjust = .5),
        # axis.text.y = element_text(angle = -35, hjust = .5, vjust = -1),
        axis.text.y = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())

top_dendro
```

```{r, warning=FALSE, fig.width=3, fig.height=9}
left_dendro <- 
  ggplot(segment(ddata), aes(x = x, y = y)) +
  geom_segment(aes(xend = xend, yend = yend)) +
  scale_x_continuous(name = NULL, 
                     trans = "reverse",
                     breaks = label(ddata)$x, 
                     labels = label(ddata)$label, 
                     expand = c(0, 0),
                     position = "top") +
  scale_y_reverse(name = NULL, expand = c(0, 0)) +
  # scale_y_continuous(name = NULL, expand = c(0, 0.01)) +
  coord_flip() +
  # theme_minimal() +  
  theme_dendro() +
  theme(axis.text.y = element_text(color = method_colors[label(ddata)$label], 
                                   angle = 0, hjust = 1),
        # axis.text.x = element_text(angle = -35, hjust = .5, vjust = -1),
        axis.text.x = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())

left_dendro
```

## Combined plot

```{r, fig.width=8, fig.height=7}
halfmat <- maucats_mat[labels_clust_order, labels_clust_order]
halfmat[lower.tri(halfmat, diag = T)] <- NA
halfmat_m <- melt(data.table(halfmat, keep.rownames = "method1"), 
                  id.vars = "method1", variable.name = "method2", 
                  value.name = "concordance")[method1 != method2]

na_pairs <- halfmat_m[is.na(concordance), paste(method1, method2)]

plot_dt <- copy(mconc)

plot_dt <- 
    rbindlist(list(plot_dt, 
                   copy(plot_dt)[, tmp := method1][, .(method1 = method2, 
                                                       method2 = tmp, 
                                                       featFrac, 
                                                       concordance, 
                                                       AUCAT)]))
plot_dt[, pairname := paste(method1, method2)]

plot_dt[pairname %in% na_pairs, concordance := NA]

plot_dt$method1 <- factor(plot_dt$method1, 
                          levels = labels_clust_order,
                          ordered = T)

plot_dt$method2 <- factor(plot_dt$method2, 
                          levels = rev(labels_clust_order),
                          ordered = T)

aucat_half_heatplot <- 
  ggplot(plot_dt, aes(x = featFrac, y = concordance, fill = AUCAT)) +
  geom_area() +
  facet_grid(rows = vars(method1), cols = vars(method2), drop = F) +
  scale_fill_viridis() +
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 1), expand = F) +
  # coord_fixed(xlim = c(0, 1), ylim = c(0, 1), expand = F) +
  theme_dendro() + ## theme dendro removes almost everything
  theme(legend.position = c(.8, .5), #"right",
        # strip.text = element_blank(),
        strip.background = element_blank(),
        panel.spacing = unit(.1, "lines"), 
        plot.margin = unit(c(-.5, -.5, -1, -.5), "lines"))
        # plot.margin = unit(c(0, -3, -1, -3), "lines"))
```


```{r, fig.width=9, fig.height=9}
##########
## data.table(method1 = labels_clust_order, method2 = labels_clust_order)
# ggplot(plot_dt[, .(x = .5, y = .5), by = .(method1, method2, AUCAT)], 
#        aes(x = x, y = y, color = AUCAT, size = AUCAT)) +
#   geom_point() +
#   facet_grid(rows = vars(method1), cols = vars(method2), drop = F) +
#   scale_color_viridis() +
#   coord_fixed(xlim = c(0, 1), ylim = c(0, 1), expand = F) +
#   theme_dendro() + ## theme dendro removes almost everything
#   theme(legend.position = c(.8, .5), 
#         strip.text = element_blank(), 
#         panel.border = element_rect(fill = NA, color = "red"),
#         plot.background = element_blank(),#element_rect(fill = NA, color = "gold", ),
#         strip.background = element_blank(),
#         panel.spacing = unit(.1, "lines"), 
#         plot.margin = unit(c(0, -3, -1, -3), "lines"))
```


```{r, fig.width=9, fig.height=8.5} 
aucat_half_heatplot + 
  theme(strip.text.y = element_text(angle =  0, hjust = 0),
        strip.text.x = element_text(angle = 90, hjust = 0))
```


```{r, fig.width=8, fig.height=7}
library(ggrastr)

rasterise(aucat_half_heatplot + 
            theme(strip.text = element_blank()))
```


```{r, fig.width=9, fig.height=8.5} 
# expand.grid(unique(mconc$method1), unique(mconc$method1))

# void_square_plot <- 
#   ggplot(data.table(method1 = labels_clust_order, method2 = labels_clust_order), 
#          aes(x = method1, 
#              y = method2)) +
#   geom_point(size = NA) +
#   coord_fixed(expand = F, clip = "off") +
#   scale_y_discrete(expand = c(0, 0)) +
#   scale_x_discrete(position = "top", 
#                    expand = c(0, 0)) +
#   labs(x = NULL, y = NULL) +
#   # theme_dendro() +
#   theme(axis.text = element_blank(),
#         axis.ticks = element_blank(),
#         panel.border = element_rect(fill = NULL),
#         panel.spacing = unit(0, "lines"),
#         plot.background = element_rect(fill = "gold"),
#         plot.margin = unit(c(0, 0 ,0 ,0), "lines"))
# 
# void_square_plot <- 
#   # ggplot(unique(mconc[, .(method1, method2)]), 
#   ggplot(data.table(method1 = seq_along(labels_clust_order), 
#                     method2 = seq_along(labels_clust_order)),
#          aes(x = "1", y = "1")) +
#   # geom_point(size = 1) +
#   geom_raster() +
#   coord_fixed(expand = T, clip = "off") +
#   scale_y_discrete() +
#   scale_x_discrete(position = "top") +
#   labs(x = NULL, y = NULL) +
#   facet_grid(rows = vars(method1), cols = vars(method2)) +
#   # theme_dendro() +
#   theme(axis.text = element_blank(),
#         axis.ticks = element_blank(),
#         # panel.border = element_rect(fill = "gray"),
#         panel.spacing = unit(0, "lines"),
#         # plot.background = element_rect(fill = "gold"),
#         plot.margin = unit(c(0, 0 ,0 ,0), "lines"))
```


```{r, fig.width=9, fig.height=9} 
library(patchwork)
library(gridGraphics)
# design <- "
#   #1
#   23
# "

design <- "#1\n23"

top_dendro + 
  left_dendro + 
  wrap_elements(rasterise(aucat_half_heatplot + 
                            theme(strip.text = element_blank())), 
                clip = F) + 
  # wrap_elements(panel = rasterise(void_square_plot)) + 
  plot_layout(design = design, 
              widths = c(1, 4), 
              heights = c(1, 4))
```


# Session info

```{r}
sessionInfo()
```

